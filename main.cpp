// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// [Битовые поля.]

#include <iostream>
#include <tchar.h>
#include "MyString.h"
#include "Rect.h"
#include "Circle.h"
#include "Shape.h"
#include "10zz.h"
#include "vld.h"

#define	  stop __asm nop

int main(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "Russian");
	//Задание 1.Массив объектов класса.
	{
	//Объявите и проинициализируйте массив ar из объектов
	// типа MyString. 
		printf("\n#1a\n");
		const int N = 3;
		MyString str1[N] = { "Moscow", "Chelyabinsk" , "Vologda" };
  
	//Проверка - печать строк-членов класса
		for (int i = 0; i < N; i++)
			std::cout << str1[i].GetString() << std::endl;

	//Замените размер "3" на "5", не изменяя список инициализаторов.
		printf("\n#1b\n");
		const int N2 = 5;
		MyString str2[N2] = { "Moscow", "Chelyabinsk" , "Vologda" };
		for (int i = 0; i < N2; i++)
			std::cout << str2[i].GetString() << std::endl;

	}
	stop


	//Задание 2.Массив указателей на объекты класса.
	{
		printf("\n#2\n");
	//Объявите и проинициализируйте массив arPtr из трех 
	//указателей на объекты типа MyString.
		MyString** arPtr = new MyString * [3];//массив указателей 
		arPtr[0] = new MyString("Moscow");
		arPtr[1] = new MyString("Chelyabinsk");
		arPtr[2] = new MyString("Vologda");
	
	//Печать строк-членов класса
		for (int i = 0; i < 3; i++) {
			std::cout << arPtr[i]->GetString() << std::endl;//сильно не меняется лишь меняем . на ->
		};
		for (int i = 0; i < 3; i++) {
			delete arPtr[i];//удаляем лишнюю память
		};
		delete[] arPtr;
	}
		stop


		//Задание 3.Простое наследование.Аргументы конструктора,
		// передаваемые в базовый класс.

		//Создайте иерархию классов:
		//базовый класс Shape (который описывает любую фигуру)
		//и два производных класса Rect и Circle.
		//Подумайте: какие данные и методы нужно ввести в базовый
		//и производные классы (например, любую фигуру можно сделать
		//цветной => в базовом классе можно ввести переменную, которая
		//будет определять цвет фигуры.
		//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);
	{ printf("\n#3\n");
		Shape s1;
		Rect r1(3, 2, 1, 4, RED);
		Circle c1(0, 0, 5.5, PINK);

		//В конструкторах производных классов предусмотрите передачу
		//параметра-цвета конструктору базового класса.
		//При создании и уничтожении объекта производного типа определите
		//последовательность вызовов конструкторов и деструкторов базового
		//и производного классов
		//sh, r-sh-r, c-sh-c, ~c-sh, `r-sh, `sh



			stop 
	}
			//////////////////////////////////////////////////////////////////////

				//Задание 4.Виртуальные функции.
				//4а) Модифицируйте классы Shape,Rect и Circle:
				//добавьте в каждый класс public метод void WhereAmI().
				//Реализация каждой функции должна выводить сообщение 
				//следующего вида "Now I am in class Shape(Rect или Circle)".
				//Выполните приведенный фрагмент, объясните результат.
		{ printf("\n#4a\n");
		Shape s(BLUE);
		Rect r(2, -1, -1, 2, GREEN);
		Circle c(1, 1, 3, YELLOW);


		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	shape
		r.WhereAmI();	//	rect
		c.WhereAmI();	//	circle
		stop


		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
		pShape->WhereAmI();	//shape
		pRect->WhereAmI();	// shape
		pCircle->WhereAmI(); //	shape
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r
		Shape& rCircle = c; //псевдоним c
		rShape.WhereAmI();	//вызов посредством rShape	shape
		rRect.WhereAmI();	//вызов посредством	rRect	shape
		rCircle.WhereAmI(); //вызов посредством rCircle	shape
		stop
		}

	//4б) Сделайте метод WhereAmI() виртуальным.
	//Снова выполните приведенный фрагмент, объясните разницу.

	{	printf("\n#4b\n");
		Shape s(BLUE);
		Rect r(2, -1, -1, 2, GREEN );
		Circle c(1, 1, 3, YELLOW);

	
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmIpupu();	//	shape
		r.WhereAmIpupu();	//	rect
		c.WhereAmIpupu();	//	circle
		stop


		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
    	pShape->WhereAmIpupu();	// shape
		pRect->WhereAmIpupu();	// rect
		pCircle->WhereAmIpupu(); // circle
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s; //псевдоним s
		Shape& rRect = r; //псевдоним r
		Shape& rCircle = c; //псевдоним c
    	rShape.WhereAmIpupu();	//вызов посредством rShape	shape
		rRect.WhereAmIpupu();	//вызов посредством	rRect	rect
		rCircle.WhereAmIpupu(); //вызов посредством rCircle	circle
		stop
	}


//////////////////////////////////////////////////////////////////////

	//Задание 5.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.

	//// Без ключевого слова virtual вызывается только базового класса, из-за чего могут создаваться утечки памяти

	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.

	
	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте
	printf("\n#5\n");
		Rect r(7,3,3,7, BLACK);
		Shape* ar[]={new Shape(r), new Rect(r), new Circle(r), new Circle() };//дописан конструктор в circle
		//Вызовите для каждого элемента массива метод WhereAmI()
		for (int i = 0; i < 4; i++) {
			ar[i]->WhereAmIpupu();
			delete ar[i];
		}

	stop



	//Задание 6*. В чем заключается отличие 1) и 2)
	{ printf("\n#6\n");
		Shape* pShapes = new Rect[10];// создали массив из объектов Rect и установили указатель на Shape на начало первого элемента массива
		Rect* pRects = new Rect[10];// создали массив из объектов Rect и установили указатель на Rect на начало первого элемента массива

		//Попробуйте вызвать метод WhereAmIVirtual() для каждого элемента обоих массивов -
		//в чем заключается проблема??? 
		//проблема в том, что классы Shape и Rect занимают разное количество памяти
							   //и при перестановке указатель Shape * начинает указывать в неопределенное место памяти. 
		for (int i = 0; i < 10; i++) {
			static_cast<Rect*>(pShapes)[i].WhereAmIpupu();//rect
			pRects[i].WhereAmIpupu();//rect
		}

		//Освободите динамически захваченную память
		delete[] pShapes;
		delete[] pRects;
		stop
	}



//////////////////////////////////////////////////////////////////////

	//Задание 7.Виртуальные функции и оператор разрешения области видимости. полиморфные объекты

	{	printf("\n#7\n");
		Rect r(2, 0, 2, 0, PINK);
		Shape* p = &r;	// Указатель ссылается на объект производного класса:
		p->WhereAmIpupu();//Rect, позднее связывание
		stop
	
		
		//4a Оператор разрешения области видимости.
		//Посредством объекта r и указателя p вызовите виртуальную функцию
		//WhereAmI()класса Shape
			p->Shape::WhereAmIpupu();//Shape, обход механизмов виртуального метода
		
	}


//////////////////////////////////////////////////////////////////////

	//Задание 8.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{	printf("\n#8\n");
		Rect r(2,0,2,0, BLUE);
		Shape* p = &r;
		p->inflate(5);
		Circle c(0,0,2,GREEN);
		p = &c;
		p->inflate(5);
	}



//////////////////////////////////////////////////////////////////////
	//Задание 9. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров
	printf("\n#9\n");
	MyString conc_str = cochet("Я", "Боюсь", "Битого", "Стекла", 0);


////////////////////////////////////////////////////////////////////////

	//Задание 10. Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	printf("\n#10\n");
	printf("\nВы можете указывать числа, не превышающие 255 (в десятичной системе счисления)\n");
	Byte byte(0x1f);
//а
	byte.ShowHex();
	byte.ShowBin();
	byte.ShowDec();
	byte.ShowOct();
//б
	byte.ShowSmbHex(0);
	byte.ShowSmbHex(1);
	byte.ShowSmbOct(1);
	byte.ShowSmbOct(0);
	byte.ShowSmbBin(3);

//в
	byte.EditBin(7,0);
	byte.ShowBin();
	byte.EditOct(2, 5);
	byte.ShowOct();
	byte.EditHex(1, 8);
    byte.ShowHex();



	return 0;
}//endmain

